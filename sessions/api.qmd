---
title: "Atelier pour d√©couvrir la r√©cup√©ration de donn√©es via des API"
author: Lino Galiana
date: 2025-04-09
description: |
  Les __API__ (_Application Programming Interface_) sont un mode d'acc√®s aux donn√©es en expansion. Gr√¢ce aux API, l'automatisation de scripts est facilit√©e puisqu'il n'est plus n√©cessaire de stocker un fichier, et g√©rer ses versions, mais uniquement de requ√™ter une base et laisser au producteur de donn√©es le soin de g√©rer les mises √† jour de la base.
number-sections: true
image: https://minio.lab.sspcloud.fr/lgaliana/generative-art/pythonds/serveurpython.jpg
---

<a href="https://datalab.sspcloud.fr/launcher/ide/vscode-python?name=SSPHub-Atelier-API&version=2.2.7&s3=region-ec97c721&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2FInseeFrLab%2Fssphub-ateliers%2Frefs%2Fheads%2Fmain%2Finit%2Fapi.sh¬ª&networking.user.enabled=true&autoLaunch=true" target="_blank" rel="noopener" data-original-href="https://datalab.sspcloud.fr/launcher/ide/vscode-python?name=SSPHub-Atelier-API&version=2.2.7&s3=region-ec97c721&init.personalInit=¬´https%3A%2F%2Fraw.githubusercontent.com%2FInseeFrLab%2Fssphub-ateliers%2Frefs%2Fheads%2Fmain%2Finit%2Fapi.sh¬ª&networking.user.enabled=true&autoLaunch=true"><img src="https://custom-icon-badges.demolab.com/badge/SSP%20Cloud-Lancer_avec_VSCode-blue?logo=vsc&amp;logoColor=white" alt="Onyxia"></a>
<a href="https://inseefrlab.github.io/ssphub-ateliers/sessions/api.ipynb" target="_blank" rel="noopener" data-original-href="https://inseefrlab.github.io/ssphub-ateliers/sessions/api.ipynb"><img src="https://custom-icon-badges.demolab.com/badge/download--notebook-black.svg?logo=download-cloud&logoSource=feather" alt="Onyxia"></a><br>

::: {.tip collapse="true"}
## Source d'inspiration

Cet atelier s'inspire fortement du chapitre consacr√© aux API dans le cours de [_Python pour la data science_](https://pythonds.linogaliana.fr/content/manipulation/04c_API_TP.html) de l'ENSAE. Les principales diff√©rences avec celui-ci sont dans la partie relative aux API authentifi√©es : nous proposons ici l'utilisation d'une API de l'Insee plut√¥t que de l'INPI.
:::

Pour installer toutes les d√©pendances n√©cessaires pour ce tutoriel, vous pouvez taper,
en ligne de commande:

```{.bash}
uv pip install -r pyproject.toml --system
```

::: {.content-visible when-format="html"}

<details open>

<summary>

Afficher les _slides_ associ√©es

</summary>

<div class="sourceCode" id="cb1"><pre class="sourceCode yaml code-with-copy"><code class="sourceCode yaml"></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><iframe class="sourceCode yaml code-with-copy" src="https://inseefrlab.github.io/ssphub-ateliers-slides/slides-data/api.html#/title-slide"></iframe></div>


_[Cliquer ici](https://inseefrlab.github.io/ssphub-ateliers-slides){target="_blank"}
pour les afficher en plein √©cran._

</details>


<details>

<summary>

Regarder le _replay_ de la session _live_ du 09 Avril 2025:

</summary>

{{< video https://minio.lab.sspcloud.fr/lgaliana/ssphub/replay/atelier_api_20240409/video1643065335.mp4 >}}


</details>


:::

# Introduction : Qu'est-ce qu'une API ?

Vous √™tes certainement habitu√© √† r√©cup√©rer vos donn√©es depuis des fichiers type CSV ou par _webscraping_[^def-webscraping]. Le webscraping est un pis-aller pour acc√©der √† de la donn√©e.

[^def-webscraping]: Technique consistant √† singer le comportement d'un navigateur web et de r√©cup√©rer de l'information en moissonnant le HTML auquel acc√®de un site web

Heureusement, il existe d'autres mani√®res d'acc√©der √† des donn√©es : les API de donn√©es. En informatique, une API est un __ensemble de protocoles permettant √† deux logiciels de communiquer entre eux__. Par exemple, on parle parfois d'API Pandas ce qui d√©signe le fait que `Pandas` est une interface entre votre code `Python` et un langage compil√© plus efficace (`C`) qui fait les calculs que vous demandez au niveau de `Python`. L‚Äôobjectif d‚Äôune API est ainsi de fournir un point d‚Äôacc√®s √† une fonctionnalit√© qui soit facile √† utiliser et qui masque les d√©tails de la mise en oeuvre.

Dans cet atelier, nous nous int√©ressons principalement aux API de donn√©es. Ces derni√®res sont simplement une fa√ßon de mettre √† disposition des donn√©es : plut√¥t que de laisser l‚Äôutilisateur consulter directement des bases de donn√©es (souvent volumineuses et complexes), l‚ÄôAPI lui propose de formuler une requ√™te qui est trait√©e par le serveur h√©bergeant la base de donn√©es, puis de recevoir des donn√©es en r√©ponse √† sa requ√™te.

L'utilisation accrue d'API dans le cadre de strat√©gies open-data est l'un
des piliers des 15 feuilles de route minist√©rielles fran√ßaises
en mati√®re d‚Äôouverture, de circulation et de valorisation des donn√©es publiques.

:::: {.tip collapse="false"}
## Illustration avec l'API BAN

Imaginons ce qui se passe lorsqu'on requ√™te l'API BAN (Base d'Adresses Nationale), en prenant la m√©taphore d'un restaurant :

* üí¨ Via `Python` {{< fa brands python >}}, on passe une commande √† l'API: des adresses plus ou moins compl√®tes avec des instructions annexes comme le code commune. Ces instructions annexes peuvent s'apparenter √† des informations fournies au serveur du restaurant comme des interdits alimentaires qui vont personnaliser la recette.

* üßë‚Äçüç≥ A partir de ces instructions, la confection du plat est lanc√©e. En l'occurrence, il s'agit de faire tourner sur les serveurs d'Etalab une routine qui va chercher dans un r√©f√©rentiel d'adresses celle qui est la plus similaire √† celle qu'on a demand√©e en adaptant √©ventuellement en fonction des instructions annexes qu'on a fournies.

* üçï Une fois que la cuisine a fini la pr√©paration du plat, on le renvoie au client. En l'occurrence, le plat sera constitu√© des coordonn√©es g√©ographiques qui correspondent √† l'adresse la plus similaire.

Le client n'a donc qu'√† se pr√©occuper de faire une bonne requ√™te et d'appr√©cier le plat qui lui est fourni. L'intelligence dans la mise en oeuvre est laiss√©e aux sp√©cialistes qui ont con√ßu l'API. Peut-√™tre que d'autres sp√©cialistes, par exemple _Google Maps_, mettent en oeuvre une recette diff√©rente pour ce m√™me plat (des coordonn√©es g√©ographiques) mais ils vous proposeront probablement un r√©sultat tr√®s similaire. Ce mode de fonctionnement vous simplifie beaucoup la vie : pour changer de restaurant, il vous suffit g√©n√©ralement de changer quelques lignes de code d'appel √† une API plut√¥t que de modifier un ensemble long et complexe de m√©thodes d'identification d'adresses.

::::


# D√©couverte des concepts principaux avec l'API BAN

Une API a donc vocation √† servir d'interm√©diaire entre un client et un serveur. Ce client peut √™tre de deux types : une interface web ou un logiciel de programmation. L'API ne fait pas d'_a priori_ sur l'outil qui sert lui passe une commande, elle lui demande seulement de respecter un standard (en g√©n√©ral une requ√™te http), une structure de requ√™te (les arguments) et d'attendre le r√©sultat.

## Comprendre le principe avec un exemple interactif

Le premier mode (acc√®s par un navigateur) est principalement utilis√© lorsqu'une interface web permet √† un utilisateur de faire des choix afin de lui renvoyer des r√©sultats correspondant √† ceux-ci. Prenons √† nouveau l'exemple de l'API de g√©olocalisation que nous utiliserons dans ce chapitre. Imaginons une interface web permettant √† l'utilisateur deux choix : un code postal et une adresse. Cela sera inject√© dans la requ√™te et le serveur r√©pondra avec la g√©olocalisation adapt√©e.

::: {.content-visible when-format="ipynb"}
Une d√©monstration interactive est disponible sur https://inseefrlab.github.io/ssphub-ateliers/sessions/api.html
:::

::: {.content-visible when-format="html"}


:::: {.columns}

::: {.column width="46%"}

```{ojs}
//| echo: false
//| label: form-codePostal
viewof codePostal = Inputs.text({value: "92120", placeholder: "92120", label: md`**Code Postal**`})
```

:::

::: {.column width="4%"}

:::

::: {.column width="46%"}

```{ojs}
//| echo: false
//| label: form-adresse-ojs
viewof adresse = Inputs.text({value: defaultAdresse, placeholder: defaultAdresse, label: md`**Adresse**`})
```

:::

::::

```{ojs}
//| echo: false
md`
${
await mj`$$\underbrace{\text{${apiroot}}}_{\text{API root}}/\underbrace{\text{search}}_{\text{API endpoint}}/?\underbrace{\text{${param1}}}_{\text{main parameter}}\&\underbrace{\text{${param2}}}_{\text{additional parameter}}$$`
}
`
```

```{ojs}
//| echo: false
map = {
  const container = html`<div style="height:300px;">`;
  yield container;
  const map = L.map(container).setView([latitude, longitude], 13);
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    attribution: "&copy; <a href=https://www.openstreetmap.org/copyright>OpenStreetMap</a> contributors"
  }).addTo(map);
  var marker = L.marker([latitude, longitude]).addTo(map);
  marker.bindPopup("<b>Trouv√© !</b>").openPopup();
  return map
}
```

üîé Allons voir ce que cela donne dans l'onglet `R√©seau` des outils de d√©veloppement de notre navigateur (dans `firefox`, raccourci {{< fa brands firefox >}} <kbd>CTRL</kbd>+<kbd>MAJ</kbd>+<kbd>K</kbd>).


```{ojs}
//| echo: false
html`
 Pour preuve que cette requ√™te est bien fonctionnelle, on peut l'ouvrir dans un navigateur : <a href="${url}" target="_blank" title="Test de url dans un navigateur">
 <i class="fa-solid fa-magnifying-glass"></i></i>
`
```


Ce qui nous donne un output au format _JSON_, le format de sortie d'API le plus commun.

Si on veut un beau rendu, comme la carte ci-dessus, il faudra que le navigateur retravaille cet _output_, ce qui se fait normalement avec `Javascript`, le langage de programmation embarqu√© par les navigateurs.

:::





## Comment faire avec `Python` {{< fa brands python >}} ?

Le principe est le m√™me sauf que nous perdons l'aspect interactif. Il s'agira donc, avec `Python`, de construire l'URL voulue et d'aller chercher via une requ√™te HTTP le r√©sultat.

`Python` communique avec internet : via le **_package_ `requests`**. Ce _package_ suit le protocole HTTP o√π on retrouve principalement deux types de requ√™tes : `GET` et `POST` :

* La requ√™te `GET` est utilis√©e pour r√©cup√©rer des donn√©es depuis un serveur web. C'est la m√©thode la plus simple et courante pour acc√©der aux ressources d'une page web. Nous allons commencer par d√©crire celle-ci.
* La requ√™te `POST` est utilis√©e pour envoyer des donn√©es au serveur, souvent dans le but de cr√©er ou de mettre √† jour une ressource. Sur les pages web, elle sert souvent √† la soumission de formulaires qui n√©cessitent de mettre √† jour des informations sur une base (mot de passe, informations clients, etc.). Nous verrons son utilit√© plus tard, lorsque nous commencerons √† rentrer dans les requ√™tes authentifi√©es o√π il faudra soumettre des informations suppl√©mentaires √† notre requ√™te.

Faisons un premier test avec `Python` en faisant comme si nous connaissions bien cette API.

```{python}
#| echo: true
#| label: ban-first-example
import requests
adresse = "88 avenue verdier"
url_ban_example = f"https://api-adresse.data.gouv.fr/search/?q={adresse.replace(" ", "+")}&postcode=92120"
requests.get(url_ban_example)
```

Qu'est-ce qu'on obtient ? Un __code HTTP__. Le code 200 correspond aux requ√™tes r√©ussies, c'est-√†-dire pour lesquelles le serveur est en mesure de r√©pondre. Si ce n'est pas le cas, pour une raison _x_ ou _y_, vous aurez un code diff√©rent.

::: {.tip collapse="true"}
## Les codes HTTP

Les codes de statut HTTP sont des r√©ponses standard envoy√©es par les serveurs web pour indiquer le r√©sultat d'une requ√™te effectu√©e par un client (comme un navigateur ou un script Python). Ils sont class√©s en diff√©rentes cat√©gories selon le premier chiffre du code :

* 1xx : Informations
* 2xx : Succ√®s
* 3xx : Redirections
* 4xx : Erreurs c√¥t√© client
* 5xx : Erreurs c√¥t√© serveur

Ceux √† retenir sont : 200 (succ√®s), 400 (requ√™te mal structur√©e), 401 (authentification non r√©ussie), 403 (acc√®s interdit), 404 (ressource demand√©e n'existe pas), 503 (le serveur n'est pas en capacit√© de r√©pondre)
:::


Pour r√©cup√©rer le contenu renvoy√© par `requests`, il existe plusieurs m√©thodes. Quand on un JSON bien formatt√©, le plus simple est d'utiliser la m√©thode `json` qui transforme cela en dictionnaire :


```{python}
#| echo: true
#| label: ban-example-json
#| output: true
req = requests.get(url_ban_example)
localisation_insee = req.json()
localisation_insee
```

::: {.content-hidden when-format="ipynb"}

```{python}
#| echo: false
ojs_define(localisation_insee = localisation_insee)
```


```{ojs}
//| echo: true
localisation_insee
```

:::

En l'occurrence, on voit que les donn√©es sont dans un JSON imbriqu√©. Il faut donc d√©velopper un peu de code pour r√©cup√©rer les informations voulues dans celui-ci:

```{python}
#| echo: true
#| output: false
localisation_insee.get('features')[0].get('properties')
```

::: {.content-hidden when-format="ipynb"}

```{python}
#| echo: false
ojs_define(localisation_insee2 = localisation_insee.get('features')[0].get('properties'))
```

:::

::: {.content-hidden when-format="ipynb"}

```{ojs}
//| echo: false
localisation_insee2
```

:::

C'est l√† l'inconv√©nient principal de l'usage des API : le travail _ex post_ sur les donn√©es renvoy√©es est parfois important. Le code n√©cessaire est propre √† chaque API puisque l'architecture du JSON d√©pend de chaque API.


## Comment conna√Ætre les _inputs_ et _outputs_ des API ?

Ici on a pris l'API BAN comme un outil magique dont on connaissait les principaux _inputs_ (le _endpoint_, les param√®tres et leur formattage...).
Mais comment faire, en pratique, pour en arriver l√† ? Tout simplement en lisant la documentation lorsqu'elle existe et en testant celle-ci via des exemples.

Les bonnes API proposent un outil interactif qui s'appelle le [`swagger`](https://swagger.io/docs/). C'est un site web interactif o√π sont d√©crites les principales fonctionnalit√©s de l'API et o√π l'utilisateur peut tester des exemples interactivement. Ces documentations sont souvent cr√©√©es automatiquement lors de la construction d'une API et mises √† disposition par le biais d'un point d'entr√©e `/docs`. Elles permettent souvent d'√©diter certains param√®tres dans le navigateur, voir le JSON obtenu (ou l'erreur g√©n√©r√©e) et r√©cup√©rer la requ√™te formatt√©e qui permet d'obtenir celui-ci. Ces consoles interactives dans le navigateur permettent de r√©pliquer le t√¢tonnement qu'on peut faire par ailleurs dans des outils sp√©cialis√©s comme [`postman`](https://www.postman.com/).

Concernant l'API BAN, la documentation se trouve sur <https://adresse.data.gouv.fr/api-doc/adresse>. Elle n'est pas interactive, malheureusement. Mais elle pr√©sente de nombreux exemples qui peuvent √™tre test√©s directement depuis le navigateur. Il suffit d'utiliser les URL propos√©es comme exemple. Ceux-ci sont pr√©sent√©s par le biais de `curl` (un √©quivalent de `requests` en ligne de commande Linux {{< fa brands linux >}}):

```{.python}
curl "https://api-adresse.data.gouv.fr/search/?q=8+bd+du+port&limit=15"
```

Il suffit de copier l'URL en question (`https://api-adresse.data.gouv.fr/search/?q=8+bd+du+port&limit=15`), d'ouvrir un nouvel onglet et v√©rifier que cela produit bien un r√©sultat. Puis de changer un param√®tre et v√©rifier √† nouveau, jusqu'√† trouver la structure qui convient. Et apr√®s, on peut passer √† `Python` comme le propose l'exercice suivant.


## Application

Pour la prochaine application, nous allons utiliser l'adresse suivante :

```{python}
#| echo: true
#| label: adresse-input-exo1
adresse = "88 Avenue Verdier"
```

::: {.exercise}
## Exercice 1 : Structurer un appel √† une API depuis `Python` {.unnumbered}

1. Tester sans aucun autre param√®tre, le retour de notre API. Transformer en `DataFrame` le r√©sultat.
2. Se restreindre √† Montrouge avec le param√®tre _ad hoc_ et la recherche du code insee ou code postal ad√©quat sur _Google_.
3. (Optionnel) : Repr√©senter l'adresse trouv√©e sur une carte.
:::


```{python}
#| label: exercise1-question1
#| code-fold: true
#| code-summary: "Correction question 1"
import requests
import pandas as pd

ban_root = "https://api-adresse.data.gouv.fr"
ban_search_endpoint = "search"
api_ban_q1 = f"{ban_root}/{ban_search_endpoint}?q={adresse.replace(" ", "+")}"
output_api_ban = requests.get(api_ban_q1).json().get('features')

df_avenue_verdier = pd.DataFrame(
    [out['properties'] for out in output_api_ban]
)
```

Les deux premi√®res lignes du _dataframe_ obtenu √† la question 1 devraient √™tre

```{python}
df_avenue_verdier.head(2)
```

A la question 2, la requ√™te ne renvoie cette fois qu'une seule observation, qu'on pourrait retravailler avec `GeoPandas` pour v√©rifier qu'on a bien plac√© ce point sur une carte

```{python}
#| label: exercise1-question2
#| code-fold: true
#| code-summary: "Correction question 2"
import pandas as pd
import geopandas as gpd

api_ban_q2 = f"{ban_root}/{ban_search_endpoint}?q={adresse.replace(" ", "+")}&postcode=92120"
output_q2 = requests.get(api_ban_q2).json()

output_q2 = pd.DataFrame(
    [output_q2.get("features")[0]['properties']]
)
output_q2 = gpd.GeoDataFrame(
    output_q2,
    geometry=gpd.points_from_xy(output_q2.x, output_q2.y), crs="EPSG:2154"
).to_crs(4326)
output_q2
```

Enfin, √† la question 3, on obtient cette carte (plus ou moins la m√™me que pr√©c√©demment) :

```{python}
#| label: exercise1-question3-folium
#| code-fold: true
#| code-summary: "Correction question 3"
import folium

# Extraire la longitude et la latitude
longitude = output_q2.geometry.x.iloc[0]
latitude = output_q2.geometry.y.iloc[0]

# Cr√©er une carte Folium centr√©e sur le point
m = folium.Map(location=[latitude, longitude], zoom_start=16)

# D√©finir le contenu de la popup
popup_content = f"""
<b>{output_q2['name'].iloc[0]}</b> has been found!
"""

# Ajouter le marqueur
folium.Marker(
    location=[latitude, longitude],
    popup=folium.Popup(popup_content, max_width=300),
    icon=folium.Icon(color='blue', icon='info-sign')
).add_to(m)

# Afficher la carte dans le notebook (si utilis√© dans un Jupyter Notebook)
m
```


::: {.note collapse="true"}
## Quelques exemples d'API √† conna√Ætre

Les principaux fournisseurs de donn√©es officielles proposent des API. C'est le cas notamment de l'[Insee](https://api.insee.fr/catalogue/), d'[Eurostat](https://wikis.ec.europa.eu/display/EUROSTATHELP/API+-+Getting+started), de la [BCE](https://data.ecb.europa.eu/help/data-examples), de la [FED](https://fred.stlouisfed.org/docs/api/fred/), de la [Banque Mondiale](https://datahelpdesk.worldbank.org/knowledgebase/topics/125589)...

N√©anmoins, la production de donn√©es par les institutions publiques est loin d'√™tre restreinte aux producteurs de statistiques publiques. Le portail [API gouv](https://api.gouv.fr/) est le point de r√©f√©rencement principal pour les API produites par l'administration centrale fran√ßaise ou des administrations territoriales. De nombreuses villes publient √©galement des donn√©es sur leurs infrastructures par le biais d'API, par exemple la [ville de Paris](https://opendata.paris.fr/api/explore/v2.1/console).

Les producteurs de donn√©es priv√©es proposent √©galement des API. Par exemple, la [SNCF](https://data.sncf.com/api) ou la [RATP](https://data.ratp.fr/pages/temps-reel/) proposent des API pour certains usages. Les grands acteurs du num√©rique, par exemple [`Spotify` {{< fa brands spotify >}}](<https://developer.spotify.com/web-api/>) proposent g√©n√©ralement des API pour int√©grer certains de leurs services √† des applications externes.

Cependant, il faut √™tre conscient des limites de certaines API. En premier lieu, les donn√©es partag√©es ne sont pas forc√©ment tr√®s riches pour ne pas compromettre la confidentialit√© des informations partag√©es par les utilisateurs du service ou la part de march√© du producteur qui n'a pas int√©r√™t √† vous partager ses donn√©es √† forte valeur. Il faut √©galement √™tre conscient du fait qu'une API peut dispara√Ætre ou changer de structure du jour au lendemain. Les codes de restructuration de donn√©es √©tant assez adh√©rents √† une structure d'API, on peut se retrouver √† devoir changer un volume cons√©quent de code si une API critique change substantiellement.
:::

# Plus d'exemples de requ√™tes `GET`

## Source principale

Nous allons utiliser comme base principale pour ce tutoriel la [base permanente des √©quipements](https://www.insee.fr/fr/metadonnees/source/serie/s1161), un r√©pertoire d'√©quipements publics accueillant du public.

On va commencer par r√©cup√©rer les donn√©es qui nous int√©ressent. On ne r√©cup√®re pas toutes les variables du fichier mais seulement celles qu'ils nous int√©ressent : quelques variables sur l'√©quipement, son adresse et sa commune d'appartenance.

Nous allons nous restreindre aux √©tablissements d'enseignement primaire, secondaire et sup√©rieur du d√©partement de la Haute-Garonne (le d√©partement 31). Ces √©tablissements sont identifi√©s par un code particulier, entre `C1` et `C5`.

```{python}
#| echo: true
#| label: read-bpe-parquet
import duckdb

query = """
FROM read_parquet('https://minio.lab.sspcloud.fr/lgaliana/diffusion/BPE23.parquet')
SELECT NOMRS, NUMVOIE, INDREP, TYPVOIE, LIBVOIE,
       CADR, CODPOS, DEPCOM, DEP, TYPEQU,
       concat_ws(' ', NUMVOIE, INDREP, TYPVOIE, LIBVOIE) AS adresse, SIRET
WHERE DEP = '31'
      AND starts_with(TYPEQU, 'C')
      AND NOT (starts_with(TYPEQU, 'C6') OR starts_with(TYPEQU, 'C7'))
"""

bpe = duckdb.sql(query)
bpe = bpe.to_df()

bpe.head(2)
```

## R√©cup√©rer des donn√©es √† fa√ßon gr√¢ce aux API

Nous avons vu pr√©c√©demment le principe g√©n√©ral d'une requ√™te d'API. Pour illustrer, de mani√®re plus massive, la r√©cup√©ration de donn√©es par le biais d'une API, essayons de r√©cup√©rer des donn√©es compl√©mentaires √† notre source principale. Nous allons utiliser l'annuaire de l'√©ducation qui fournit de nombreuses informations sur les √©tablissements scolaires. Nous utiliserons le SIRET pour croiser les deux sources de donn√©es.

L'exercice suivant viendra illustrer l'int√©r√™t d'utiliser une API pour avoir des donn√©es √† fa√ßon et la simplicit√© √† r√©cup√©rer celles-ci via `Python`. N√©anmoins, cet exercice illustrera √©galement une des limites de certaines API, √† savoir la volum√©trie des donn√©es √† r√©cup√©rer.


::: {.exercise}
## Exercice 2 {.unnumbered}

1. Visiter le _swagger_ de l'API de l'Annuaire de l'Education nationale sur [api.gouv.fr/documentation](https://api.gouv.fr/documentation/api-annuaire-education), et plus particuli√®rement sa ["documentation externe"](https://data.education.gouv.fr/explore/dataset/fr-en-annuaire-education/api/?disjunctive.type_etablissement&disjunctive.libelle_academie&disjunctive.libelle_region&disjunctive.ministere_tutelle&disjunctive.appartenance_education_prioritaire&disjunctive.nom_commune&disjunctive.code_postal&disjunctive.code_departement) qui permet de g√©n√©rer les urls souhait√©es en prototypant interactivement les requ√™tes. Tester une premi√®re r√©cup√©ration de donn√©es en utilisant le _endpoint_ `records` sans aucun param√®tre.
2. Puisqu'on n'a conserv√© que les donn√©es de la Haute Garonne dans notre base principale, on d√©sire ne r√©cup√©rer que les √©tablissements de ce d√©partement par le biais de notre API. Faire une requ√™te avec le param√®tre _ad hoc_, sans en ajouter d'autres.
3. Augmenter la limite du nombre de param√®tres, voyez-vous le probl√®me ?
4. On va tenter de r√©cup√©rer ces donn√©es par le biais de l'API tabular de `data.gouv`. Sa documentation est [ici](https://tabular-api.data.gouv.fr/api/doc) et l'identifiant de la ressource est `b22f04bf-64a8-495d-b8bb-d84dbc4c7983` ([source](https://www.data.gouv.fr/fr/datasets/annuaire-de-leducation/)). Avec l'aide de la documentation, essayer de r√©cup√©rer des donn√©es par le biais de cette API en utilisant le param√®tre `Code_departement__exact=031` pour ne garder que le d√©partement d'int√©r√™t.
5. Voyez-vous le probl√®me et comment nous pourrions automatiser la r√©cup√©ration de donn√©es ?
:::

```{python}
#| label: exercise2-api-education-q1
#| code-fold: true
#| code-summary: R√©ponse question 1
import requests

url_annuaire_education = "https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records"

school_q1_exo2 = pd.DataFrame(
  requests
  .get(url_annuaire_education)
  .json()
  .get("results")
)

school_q1_exo2.head(2)
```

N√©anmoins, on a deux probl√®mes : le nombre de lignes et le d√©partement d'int√©r√™t. Essayons d√©j√† avec la question 2 de changer ce dernier.

```{python}
#| label: exercise2-api-education-q2
#| code-fold: true
#| code-summary: "R√©ponse question 2"
url_31_limite10 = "https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records?where=code_departement%20like%20%22031%22"

school_q2_exo2 = pd.DataFrame(
  requests
  .get(url_31_limite10)
  .json()
  .get("results")
)
school_q2_exo2.head()
```

C'est mieux, mais nous avons toujours seulement 10 observations. Si on essaie d'ajuster le nombre de lignes (question 3), on obtient le retour suivant de l'API :

```{python}
#| code-fold: true
#| code-summary: "Question 3"
url_31_limite200 = "https://data.education.gouv.fr/api/explore/v2.1/catalog/datasets/fr-en-annuaire-education/records?where=code_departement%20like%20%22031%22&limit=200"

requests.get(url_31_limite200).json()
```

Essayons avec des donn√©es plus exhaustives : le fichier brut sur `data.gouv`. Comme on peut le voir dans les m√©tadonn√©es, on sait qu'on a plus de 1000 √©coles dont on peut r√©cup√©rer des donn√©es, mais qu'on en a ici extrait seulement 20. Le champ `next` nous donne directement l'URL √† utiliser pour r√©cup√©rer les 20 pages suivantes : c'est gr√¢ce √† lui qu'on a une chance de r√©cup√©rer toutes nos donn√©es d'int√©r√™t.

```{python}
#| label: exercise2-api-datagouv
#| code-fold: true
#| code-summary: "R√©ponse question 4"
url_api_datagouv = "https://tabular-api.data.gouv.fr/api/resources/b22f04bf-64a8-495d-b8bb-d84dbc4c7983/data/?Code_departement__exact=031"

call_api_datagouv = requests.get(url_api_datagouv).json()
```

Le probl√®me de la r√©cup√©ration de donn√©es via l'API vient du fait que nous ne r√©cup√©rons qu'un petit √©chantillon √† chaque requ√™te. Pour y rem√©dier, nous allons devoir faire plusieurs appels successifs. Dans le JSON obtenu ci-dessus, la partie int√©ressante pour automatiser la r√©cup√©ration de nos donn√©es est la cl√© `links`. En bouclant sur celui-ci pour parcourir la liste des URL accessibles, on peut r√©cup√©rer des donn√©es.

```{python}
#| echo: true
#| output: false
#| label: exercise2-api-tabular
#| code-fold: true
#| code-summary: "R√©ponse question 5"
import requests
import pandas as pd

# Initialize the initial API URL
url_api_datagouv = "https://tabular-api.data.gouv.fr/api/resources/b22f04bf-64a8-495d-b8bb-d84dbc4c7983/data/?Code_departement__exact=031&page_size=50"

# Initialize an empty list to store all data entries
all_data = []

# Initialize the URL for pagination
current_url = url_api_datagouv

# Loop until there is no next page
while current_url:
    try:
        # Make a GET request to the current URL
        response = requests.get(current_url)
        response.raise_for_status()  # Raise an exception for HTTP errors

        # Parse the JSON response
        json_response = response.json()

        # Extract data and append to the all_data list
        page_data = json_response.get('data', [])
        all_data.extend(page_data)
        print(f"Fetched {len(page_data)} records from {current_url}")

        # Get the next page URL
        links = json_response.get('links', {})
        current_url = links.get('next')  # This will be None if there's no next page

    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")
        break

```


```{python}
#| echo: true
schools_dep31 = pd.DataFrame(all_data)
schools_dep31.head()
```


On peut fusionner ces nouvelles donn√©es avec nos donn√©es pr√©c√©dentes pour enrichir celles-ci. Pour faire une production fiable, il faudrait faire attention aux √©coles qui ne s'apparient pas, mais ce n'est pas grave pour cette s√©rie d'exercices.

```{python}
#| echo: true
#| label: exercise2-bpe-enriched
bpe_enriched = bpe.merge(
  schools_dep31,
  left_on = "SIRET",
  right_on = "SIREN_SIRET"
)
bpe_enriched.head(2)
```

Cela nous donne des donn√©es enrichies de nouvelles caract√©ristiques sur les √©tablissements. Il y a des coordonn√©es g√©ographiques dans celles-ci, mais nous allons faire comme s'il n'y en avait pas pour r√©utiliser notre API de g√©olocalisation et ainsi avoir un alibi pour utiliser les requ√™tes `POST`.

# D√©couverte des requ√™tes `POST`

## Logique

Nous avons jusqu'√† pr√©sent √©voqu√© les requ√™tes `GET`. Nous allons maintenant pr√©senter les requ√™tes `POST` qui permettent d'interagir de mani√®re plus complexe avec des serveurs de l'API.

Pour d√©couvrir celles-ci, nous allons reprendre l'API de g√©olocalisation pr√©c√©dente mais utiliser un autre point d'entr√©e qui n√©cessite une requ√™te `POST`.

Ces derni√®res sont g√©n√©ralement utilis√©es quand il est n√©cessaire d'envoyer des donn√©es particuli√®res pour d√©clencher une action. Par exemple, dans le monde du web, si vous avez une authentification √† mettre en oeuvre, une requ√™te `POST` permettra d'envoyer un _token_ au serveur qui r√©pondra en acceptant votre authentification.

Dans notre cas, nous allons envoyer des donn√©es au serveur, ce dernier va les recevoir, les utiliser pour la g√©olocalisation puis nous envoyer une r√©ponse. Pour continuer sur la m√©taphore culinaire, c'est comme si vous donniez vous-m√™mes √† la cuisine un _tupperware_ pour r√©cup√©rer votre plat √† emporter.

## Principe

Prenons cette requ√™te propos√©e sur le site de [documentation](https://adresse.data.gouv.fr/outils/api-doc/adresse) de l'API de g√©olocalisation :

```{.bash}
curl -X POST -F data=@path/to/file.csv -F columns=voie -F columns=ville -F citycode=ma_colonne_code_insee https://api-adresse.data.gouv.fr/search/csv/
```
Ici l'objectif est d'obtenir des g√©olocalisations pour les adresses textuelles pr√©sentes dans un fichier .csv.

Comme nous avons pu l'√©voquer pr√©c√©demment, `curl` est un outil en ligne de commande qui permet de faire des requ√™tes API. L'option `-X POST` indique, de mani√®re assez transparente, qu'on d√©sire faire une requ√™te `POST`.

Les autres arguments sont pass√©s par le biais des options `-F`. En l'occurrence, on envoie un fichier et on ajoute des param√®tres pour aider le serveur √† aller chercher la donn√©e dedans. L'`@` indique que `file.csv` doit √™tre lu sur le disque et envoy√© dans le corps de la requ√™te comme une donn√©e de formulaire.

## Application avec `Python`

Nous avions `requests.get`, il est donc logique que nous ayons `requests.post`. Cette fois, il faudra passer des param√®tres √† notre requ√™te sous la forme d'un dictionnaire dont les cl√©s sont le nom de l'argument et les valeurs sont des objets `Python`.

Le principal d√©fi, illustr√© dans le prochain exercice, est le passage de l'argument `data` : il faudra renvoyer le fichier comme un objet `Python` par le biais de la fonction `open`.


::: {.exercise}
## Exercice 3 : une requ√™te `POST` pour g√©olocaliser en masse nos donn√©es {.unnumbered}

1. Enregistrer au format CSV les colonnes `adresse`, `DEPCOM` et `Nom_commune` de la base d'√©quipements fusionn√©e avec notre r√©pertoire pr√©c√©dent (objet `bpe_enriched`). Il peut √™tre utile, avant l'√©criture au format CSV, de remplacer les virgules dans la colonne `adresse` par des espaces.
2. Cr√©er l'objet `response` avec `requests.post` et les bons arguments pour g√©ocoder votre CSV.
3. Transformer votre output en objet `Pandas` avec la commande suivante :

```{.python}
bpe_loc = pd.read_csv(io.StringIO(response.text))
```

:::

```{python}
#| label: exercise3-q1
#| code-fold: true
#| code-summary: "R√©ponse question 1"

import pathlib
output_path = pathlib.Path("data/output")
output_path.mkdir(parents=True, exist_ok=True)
csv_file = output_path / "bpe_before_geoloc.csv"

bpe_enriched["adresse"] = bpe_enriched["adresse"].str.replace(",", "")

bpe_enriched.loc[:, ["adresse", "DEPCOM", "Nom_commune"]].to_csv(csv_file)
```

```{python}
#| code-fold: true
#| code-summary: "R√©ponse question 2 et 3"

import io

params = {
    "columns": ["adresse", "Nom_commune"],
    "citycode": "DEPCOM",
    "result_columns": ["result_score", "latitude", "longitude"],
}

response = requests.post(
        "https://api-adresse.data.gouv.fr/search/csv/",
        data=params,
        files={"data": open(csv_file, "rb")},
    )


bpe_loc = pd.read_csv(io.StringIO(response.text))
bpe_loc = bpe_loc.rename({"Unnamed: 0": "index"}, axis = "columns")
```

Les g√©olocalisations obtenues prennent cette forme

```{python}
bpe_loc.head(2)
```

On peut ensuite faire la jointure √† nos donn√©es initiales :

```{python}
#| label: exercise3-q2
#| code-fold: true
#| code-summary: "Jointure aux donn√©es initiales"
bpe_loc = bpe_loc.loc[:, ["index", "result_score", "latitude", "longitude"]]
bpe_enriched_geocoded = (
  bpe_enriched
  .reset_index()
  .merge(bpe_loc, on = "index", suffixes = ["_annuaire", "_ban"])
  .drop("index", axis = "columns")
)

bpe_enriched_geocoded.head(2)
```

```{python}
#| label: exercise3-q3
#| code-fold: true
#| code-summary: "Jointure aux donn√©es initiales"

bpe_enriched_geocoded = (
    bpe_enriched_geocoded
    .dropna(subset=["longitude_ban","latitude_ban"])
)

bpe_enriched_geocoded = gpd.GeoDataFrame(
    bpe_enriched_geocoded,
    geometry=gpd.points_from_xy(
      bpe_enriched_geocoded['longitude_ban'],
      bpe_enriched_geocoded['latitude_ban']
      ),
    crs="EPSG:4326"
)
```


Pour profiter de nos donn√©es enrichies, on peut faire une carte. Pour ajouter un peu de contexte √† celle-ci, on peut mettre un fond de carte des communes en arri√®re plan. Celui-ci peut √™tre r√©cup√©r√© avec `cartiflette` :


```{python}
#| echo: true
#| label: carti-download
#| code-fold: true
#| code-summary: "R√©cup√©ration du fond de carte (GEOJSON)"
from cartiflette import carti_download
shp_communes = carti_download(
  crs = 4326,
  values = ["31"],
  borders="COMMUNE",
  vectorfile_format="topojson",
  filter_by="DEPARTEMENT",
  source="EXPRESS-COG-CARTO-TERRITOIRE",
  year=2022
)
shp_communes.crs = 4326
```


```{python}
#| label: cartiflette-map
#| code-fold: true
#| code-summary: "Code pour la carte interactive"
import folium
from folium.plugins import MarkerCluster
import geopandas as gpd

department_border = shp_communes.dissolve(by="INSEE_DEP")
city_borders = shp_communes.copy()

longitude = bpe_enriched_geocoded.geometry.x.iloc[0]
latitude = bpe_enriched_geocoded.geometry.y.iloc[0]
m = folium.Map(location=[latitude, longitude], zoom_start=10)

# Add department border (black, bold)
folium.GeoJson(
    data=department_border,
    style_function=lambda x: {
        "fill": False,
        "color": "black",
        "weight": 3  # Bold border
    }
).add_to(m)

# Add city borders (blue, thin)
folium.GeoJson(
    data=city_borders,
    style_function=lambda x: {
        "fill": False,
        "color": "blue",
        "weight": 1  # Thin border
    }
).add_to(m)

# Initialize the MarkerCluster
marker_cluster = MarkerCluster().add_to(m)

def generate_popup(row):
    # Initialiser le contenu avec le nom de l'√©cole
    popup_content = f"<b>Nom:</b> {row['NOMRS']}<br>"

    # Ajouter "Ecole √©l√©mentaire" avec une ic√¥ne ‚úÖÔ∏è ou ‚ùåÔ∏è selon la valeur
    ecole_element_status = "‚úÖÔ∏è" if row.get('Ecole_elementaire', False) else "‚ùåÔ∏è"
    popup_content += f"<b>Ecole √©l√©mentaire:</b> {ecole_element_status}<br>"

    # Ajouter "Nombre d'√©l√®ves" si disponible
    if not pd.isnull(row.get('Nombre_d_eleves')):
        popup_content += f"<b>Nombre d'√©l√®ves :</b> {row['Nombre_d_eleves']}<br>"

    # Ajouter "Voie g√©n√©rale" si disponible
    if not pd.isnull(row.get('Voie_generale')):
        popup_content += f"<b>Voie g√©n√©rale :</b> {row['Voie_generale']}<br>"

    # Ajouter "Voie technologique" si disponible
    if not pd.isnull(row.get('Voie_technologique')):
        popup_content += f"<b>Voie technologique :</b> {row['Voie_technologique']}<br>"

    return popup_content


# Add GeoDataFrame points to the MarkerCluster
for _, row in bpe_enriched_geocoded.iterrows():
    # Create the popup content
    popup_content = generate_popup(row)

    popup = folium.Popup(popup_content, max_width=300)

    # Add the marker to the cluster
    folium.Marker(
        location=[row.geometry.y, row.geometry.x],  # Extract latitude and longitude
        popup=popup,
        icon=folium.Icon(color="blue", icon="info-sign")
    ).add_to(marker_cluster)

# Display the map inline (optional for Jupyter Notebooks)
m
```

# Gestion des secrets et des exceptions

Nous avons d√©j√† utilis√© plusieurs API. N√©anmoins ces derni√®res √©taient toutes sans authentification et pr√©sentent peu de restrictions, hormis le nombre d'√©chos. Ce n'est pas le cas de toutes les API. Il est fr√©quent que les API qui permettent d'aspirer plus de donn√©es ou d'acc√©der √† des donn√©es confidentielles n√©cessitent une authentification pour tracer les utilisateurs de donn√©es.

Cela se fait g√©n√©ralement en utilisant un _token_. Ce dernier est une sorte de mot de passe, souvent utilis√© dans les syst√®mes modernes d'authentification pour certifier de l'identit√© d'un.e utilisateur.trice (cf. [chapitre `Git`](/content/git/introgit.qmd)).


Avant d'en pr√©senter l'usage, nous allons faire un rapide apart√© sur la confidentialit√© des _tokens_ et la mani√®re d'√©viter de r√©v√©ler ceux-ci dans votre code.

## Bonnes pratiques pour utiliser un token dans un code sans le r√©v√©ler üëÆ

Les _tokens_ sont des informations personnelles qui ne doivent pas √™tre partag√©es. Ils n'ont donc pas vocation √† appara√Ætre dans le code.

Comme ceci est √©voqu√© √† plusieurs reprises dans le cours de [mise en production](https://ensae-reproductibilite.github.io/website/) en 3e ann√©e de l'ENSAE, il est important de s√©parer le code des √©l√©ments de configuration :

![](https://pythonds.linogaliana.fr/content/modern-ds/environment.png)

L'id√©e est de trouver une recette pour apporter les √©l√©ments de configuration avec le code mais sans mettre ceux-ci en clair dans le code. L'id√©e g√©n√©rale sera de stocker la valeur du _token_ dans une variable mais ne jamais r√©v√©ler celle-ci dans le code. Comment faire d√®s lors pour d√©clarer la valeur du jeton sans que celui-ci soit apparent dans le code ?

* Pour un code amen√© √† fonctionner de mani√®re interactive (par exemple par le biais d'un _notebook_), il est possible de cr√©er une boite de dialogue qui injectera la valeur renseign√©e dans une variable. Cela se fait par le biais du package `getpass`.
* Pour le code qui tourne en non interactif, par exemple par le biais de la ligne de commande, l'approche par variable d'environnement est la plus fiable, √† condition de faire attention √† ne pas mettre le fichier de mot de passe dans `Git` {{< fa brands git-alt >}}. Pour cela, le plus simple est d'utiliser [`dotenv`](https://pypi.org/project/python-dotenv/) si vous faites tourner votre code ou des [secrets](https://docs.github.com/fr/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions) si votre code tourne par le biais de l'int√©gration continue[^gha].

[^gha]: C'est par exemple l'approche adopt√©e pour construire ces supports. Cela se fait de [cette mani√®re](XXXX).

::: {.important}
Il ne faut jamais mettre de _token_ dans `Git`. Sinon, vous courrez le risque d'avoir votre identit√© usurp√©e : des robots scannent en continu  `Github` √† la recherche de jetons pour ensuite lancer des d√©nis de service en se faisant passer pour vous.

Si vous avez partag√© par erreur un jeton : pas de panique, cela peut arriver ! L'avantage des jetons est qu'ils sont r√©vocables : vous pouvez l'invalider et en cr√©er un nouveau pour continuer √† utiliser le service d√©sir√©. La bonne r√©action consiste √† r√©voquer le jeton le plus vite possible, une fois la fuite constat√©e. La meilleure parade pour √©viter ce type de fuite est d'ajouter tout de suite le `.env` au `.gitignore`.
:::


L'exercice 5 permettra de mettre en oeuvre ces deux m√©thodes. Ces m√©thodes nous serviront √† ajouter de mani√®re confidentielle un _payload_ √† des requ√™tes d'authentification, c'est-√†-dire des informations confidentielles identifiantes en compl√©ment d'une requ√™te.


## Le portail des API de l'Insee

Pour illustrer l'utilisation des API authentifi√©es, nous proposons d'explorer le [portail des API](https://api.insee.fr/catalogue/) de l'Insee.

Nous allons nous concentrer sur l'API Sirene mais, sur ce portail, il en existe d'autres, notamment l'API Melodi consacr√©e √† la r√©cup√©ration d'un certain nombre de sources _open data_ de l'Insee. L'API Sirene est une version interrogeable des donn√©es [Sirene _open data_](https://www.insee.fr/fr/information/3591226).




::: {.exercise}
## Exercice 4 : API authentifi√©e par le biais du navigateur {.unnumbered}

1. Se cr√©er un compte sur le [portail des API](https://api.insee.fr/catalogue/)
2. Aller voir l'espace `Mes applications` et en cr√©er une nouvelle. Par simplicit√©, vous pouvez la nommer _"Atelier SSPHub"_.
3. Dans celle-ci, aller dans l'onglet _"Clefs et jetons"_.Cr√©er un jeton (vous pouvez laisser la dur√©e de validit√© propos√©e).
4. Cliquer sur l'onglet _Souscriptions_. Choisir l'API Sirene.
5. A droite, s√©lectionner l'application cr√©√©e pr√©c√©demment. Si vous allez voir votre application, elle devrait maintenant pouvoir interagir avec l'API Sirene.

Testons maintenant l'API Sirene gr√¢ce au _swagger_ (onglet `Console de l'API`) :

6. Plus bas, dans la documentation interactive se rendre au point d'entr√©e `/siren/{siren}` (m√©thode `GET`).
7. Remplir le champ `q` avec le SIREN `500569405` (SIREN de D√©cathlon üòâ)
8. Si vous avez l'erreur ci-dessous, comprenez-vous pourquoi ?

::: {.content-hidden when-format="html"}

```{ojs}
//| echo: false
error_request_no_token
```

:::

1. Changer l'application via le menu d√©roulant : maintenant que vous avez un _token_ valide, soumettez √† nouveau la m√™me requ√™te.

Vous devriez maintenant avoir cette sortie :

```{ojs}
//| echo: false
sortie_sirene_decathlon
```

:::

## R√©cup√©ration des donn√©es via `Python` {{< fa brands python >}}

Pour la prochaine application, √† partir de la question 4, nous allons avoir besoin de cr√©er une classe sp√©ciale permettant √† `requests` de surcharger notre requ√™te d'un jeton d'authentification. Comme elle n'est pas triviale √† cr√©er sans connaissance pr√©alable, la voici :

```{python}
#| echo: true
#| label: bearer-token
class BearerAuth(requests.auth.AuthBase):
    def __init__(self, token):
        self.token = token
    def __call__(self, r):
        r.headers["authorization"] = "Bearer " + self.token
        return r
```


::: {.exercise}
## Exercice 5 : les tokens avec `Python` {.unnumbered}

1. Cr√©er une variable `token` par le biais de `getpass`.
2. Utiliser cette structure de code pour r√©cup√©rer la donn√©e voulue

```{.python}
requests.get(
    url,
    auth=BearerAuth(token)
)
```

3. Remplacer l'utilisation de `getpass` par l'approche variable d'environnement gr√¢ce √† [`dotenv`](https://pypi.org/project/python-dotenv/).

:::


```{python}
#| code-fold: true
#| code-summary: "Correction de l'exercice"
#| output: false
#| label: premier-appel-authent
import os
from dotenv import load_dotenv

load_dotenv()

siren="500569405"
token = os.getenv("TOKEN_API_INSEE")
if token is not None:
    print("Token has been retrieved from env var")

r = requests.get(
    f"https://api.insee.fr/entreprises/sirene/V3.11/siren/{siren}",
    auth=BearerAuth(token)
)

sortie_sirene_decathlon = r.json()
sortie_sirene_decathlon
```

::: {.content-visible when-format="html"}

```{python}
#| echo: false
ojs_define(sortie_sirene_decathlon = sortie_sirene_decathlon)
```

```{ojs}
//| echo: false
sortie_sirene_decathlon
```

:::

Nous avons un _dataframe_ avec de nombreux _SIRET_ (`bpe`). On pourrait vouloir r√©cup√©rer des infos sur ceux-ci par le biais de l'API. N√©anmoins les conditions d'usage de celle-ci sont restrictives : pas plus de 30 appels par minute.

On ne peut donc faire une boucle sur notre _dataframe_ sans contr√¥ler le nombre d'appels √† la minute. Id√©alement, nous ferions de l'envoi par _bash_ qui permet d'envoyer plusieurs enregistrement √† la fois dans une seule requ√™te (comme nous avons fait pour les g√©olocalisations) mais ce n'est pas possible : l'API Sirene est une API pour de la consultation de donn√©es ponctuelles, pas du traitement statistique sur de gros volumes.

L'autre approche possible, que nous allons adopter, est de mettre un temps d'attente entre chaque appel √† l'API. Nous allons donc faire une boucle mais, entre chaque it√©ration, mettre un temps de repos de 2 secondes.


```{python}
#| code-fold: true
#| code-summary: Fonction utile pour cet exercice
#| output: false
#| eval: false
siret = "21310001900024"

def get_ape(siret: str = "21310001900024", token: str = ""):
    info_siret = requests.get(
        f"https://api.insee.fr/entreprises/sirene/V3.11/siret/{siret}",
        auth=BearerAuth(token)
    ).json()
    ape = (info_siret
        .get("etablissement", {})
        .get("uniteLegale", {})
        .get("activitePrincipaleUniteLegale", {})
    )
    return ape

get_ape(siret, token)
```


::: {.exercise}
## Exercice 6 : g√©n√©raliser des appels √† des API {.unnumbered}

Nous voulons r√©cup√©rer l'activit√© pricnipal de nos √©tablissements (le code APE, qui devrait normalement √™tre `84.11Z`).

Utiliser le _package_ `time` et sa fonction `sleep` pour marquer un temps d'arr√™t lorsqu'on it√©re sur les _dix premi√®res observations_ de notre _dataframe_ pour r√©cup√©rer ce code.

:::



```{python}
#| code-fold: true
#| code-summary: "Correction de l'exercice"
#| eval: false
import time

first_siret = []

for index, row in bpe.head(10).iterrows():
    first_siret += [get_ape(row['SIRET'], token)]
    time.sleep(2)
```

# Conclusion

Les API sont pratiques pour r√©cup√©rer des donn√©es ponctuelles, en particulier lorsque le consommateur de donn√©es n‚Äôa pas besoin d‚Äôacc√©der √† la donn√©e brute mais plut√¥t √† une version d√©j√† transform√©e, filtr√©e ou mise √† jour dynamiquement. Elles s‚Äôint√®grent bien dans des applications interactives ou des scripts automatis√©s et permettent de d√©l√©guer la gestion des mises √† jour et de la volum√©trie au fournisseur de donn√©es.

Cependant, leur utilisation pr√©sente plusieurs inconv√©nients :

* elles n√©cessitent souvent un code tr√®s sp√©cifique √† chaque source et √† chaque langage, ce qui nuit √† la portabilit√© (√† l‚Äôinverse de solutions plus universelles comme SQL, dont nous parlerons dans la _masterclass_ `Parquet`) ;

* elles posent parfois des limites en termes de volum√©trie ou de stabilit√© d‚Äôacc√®s (API d√©sactiv√©es ou restructur√©es sans pr√©avis), ce qui les rend moins adapt√©es pour un usage massif ou reproductible √† long terme.

Les API sont donc surtout int√©ressantes pour r√©cup√©rer des donn√©es ponctuelles ou embarqu√©es dans une application, mais restent √† manier avec prudence dans un contexte d‚Äôexploitation de donn√©es √† grande √©chelle ou de production statistique robuste.


::: {.content-visible when-format="html"}

<!----------
API interactive example
---------->



```{ojs}
//| echo: false
//| output: false
adresse_debounce = debounce(viewof adresse, 3000)
```

```{ojs}
//| echo: false
import {debounce} from "@mbostock/debouncing-input"
```



```{ojs}
//| echo: false
apiroot = "https://api-adresse.data.gouv.fr"
param1 = {
  const AdresseFormat = adresse_debounce.toLowerCase().replaceAll(" ", "+")
  const url = `q=${AdresseFormat}`
  return url
}
param2 = `postcode=${codePostal}`
```


```{ojs}
//| echo: false
import {mj} from "@danielefadda/mathjax"
```


```{ojs}
//| echo: false
url = {
  const AdresseFormat = adresse_debounce.toLowerCase().replaceAll(" ", "+")
  const url = `https://api-adresse.data.gouv.fr/search/?q=${AdresseFormat}&postcode=${codePostal}`
  return url
}
```

```{ojs}
//| echo: false
localisation = d3.json(url)
```

```{ojs}
//| echo: false
defaultAdresse = "88 Avenue Verdier"
longitude = localisation.features[0].geometry.coordinates[0]
latitude = localisation.features[0].geometry.coordinates[1]
```




```{ojs}
//| echo: false
import {L} from "@observablehq/hello-leaflet"
```

:::

```{python}
#| echo: false
#| label: error-authent-insee
#| eval: false
error_request_no_token = requests.get(
    f"https://api.insee.fr/entreprises/sirene/V3.11/siren/",
    headers={"Accept": "application/json"}
).json()
ojs_define(error_request_no_token=error_request_no_token)
```


